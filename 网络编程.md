# 网络编程

### I/O 多路复用

https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA

##### socket

##### select、poll

##### epoll



### Reactor和Proactor



### 协议

#### HTTP

##### 长轮询、短轮询、websocket

https://blog.csdn.net/pacosonswjtu/article/details/52035252#:~:text=1%EF%BC%89%E4%BB%8B%E7%BB%8D%EF%BC%9A%20http

**短轮询** 是指客户端在固定的时间间隔内不断向服务器发送请求，**无论服务器是否有新的数据更新**，服务器都会**立即返回当前的状态**（**很可能数据并没有准备好）**。这种方式简单易实现，但可能会导致大量的无效请求，从而增加服务器的负担和网络延迟。

**长轮询** 是一种改进的轮询方式，客户端向服务器发送请求后，如果服务器没有新的数据，它会保持连接打开状态，**直到有数据可用或者超时**。这种方式可以减少不必要的网络请求，提高实时性，但服务器需要保持连接状态，可能会占用更多的服务器资源。

【补充】http 长连接（tcp 连接可复用）

> http协议 目前有两个版本：1.1 和 1.0；区别是 1.1支持 长连接（普遍使用http1.1版本），长连接也叫做持久连接（keep-alive）；而1.0不支持长连接，在1.0版本下，每个http请求响应后都会关闭tcp连接，下一次http请求会重新建立http连接；

2）**http 长连接**：多个http 请求共用同一个 tcp 连接，这样可以减少相邻多次 http请求导致的 tcp连接建立和关闭的资源消耗；http1.1 在请求头和响应头中用 connection 字段标识 该http连接是否是 长连接，即**connection: keep-alive 表示长连接**；而 connection: closed 表明服务器关闭tcp 连接；
3）**keep-alive**：与 connection 相对应的是 keep-alive，其属性有 **timeout=30 和 max=5** 分别是 两次 http 请求 保持的时间，max表示这个tcp 连接最多被几个 http 请求重用；

---

#### **WebSocket**

定义了一种在通过一个单一的 socket 在网络上进行**全双工通讯的通道**。

>  WebSocket 是 html5 规范发布的新协议，和 http协议完全是两个不同的概念，或者说基本没关系；WebSocket 协议 和 http协议的唯一联系点在于，WebSocket 协议为了兼容现有浏览器的握手规范而采用了 http协议中的握手规范 以建立WebSocket连接；

WebSocket 协议允许客户端和服务器之间建立一个持久的连接，**服务器**可以通过这个连接**主动向客户端推送数据**（类似于推送）。这种方式提供了真正的实时通信，减少了延迟和网络流量，适合需要高度实时性的应用程序。

解决的问题：

1. **http协议的被动性**：采用 WebSocket 协议后，服务器可以主动推送消息给客户端；而不需要客户端以（长/短）轮询的方式发起http请求到server以获取数据更新反馈；这样一来，**客户端只需要经过一次HTTP请求**，就可以做到源源不断的信息传送了（在程序设计中，这种设计叫做回调，即：server 端有信息了再来通知client 端，而不是 client 端 每次都傻乎乎地跑去轮询server端 是否有消息更新）；
2. **http协议的无状态性/健忘性**：短轮询是每次http请求前都要建立连接，而长轮询是相邻几次请求前都要建立连接；http请求响应完成后，服务器就会断开连接，且把连接的信息全都忘记了；所以每次建立连接都要重新传输连接上下文（下面有补充），将 client 端的连接上下文来告诉server 端；而 WebSockct只需要一次HTTP 握手，整个通讯过程是建立在一次连接（状态）中的，server 端会一直推送消息更新反馈到客户端，直到客户端关闭请求，这样就无需 客户端为发送消息而建立不必要的 tcp 连接 和 为了建立tcp连接而发送不必要的冗余的连接上下文消息；

---

### 设计思路

> 参考boost库学习 https://gitbookcpp.llfc.club/sections/cpp/boost/asio05.html

#### :warning: 同步服务器(生产不用)

- **handleFunc** :用于处理请求服务
- **acceptor** :用于接受请求

为什么不用？

1. 同步读写的缺陷在于读写是**阻塞的**，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态。
2.  可以通过**开辟新的线程**为新生成的连接处理读写，但是一个进程开辟的线程是**有限的**，约为2048个线程，在Linux环境可以通过unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多。 
3. 该服务器和客户端为**应答式**，实际场景为全双工通信模式，发送和接收要独立分开。 
4. 该服务器和客户端未考虑粘包处理。 综上所述，是我们这个服务器和客户端存在的问题

但有一个思路可以借鉴

用队列保证

---

> 为解决上述问题，我们在接下里的文章里做不断完善和改进，主要以异步读写改进上述方案。 当然同步读写的方式也有其优点，比如客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式。使用同步读写能简化编码难度。

#### ⭐异步服务器

> 参考boost学习https://gitbookcpp.llfc.club/sections/cpp/boost/asio06.html

**必要组件**

**Server：**

- 监听，async_accept
- 接受连接 , acceptHandler
- 创建、回收会话 start_accept 、doClose

**Session:**

- 读 doRead readHandler
- 写 doWrite writeHandler
- 业务 service 也就是服务器为什么称之为服务器的地方



##### 问题处理

1. 如何全双工通讯

   读队列+写队列来实现全双工通讯。不用单队列+符号的原因是

2. 如何健壮地处理空间

   - 读、写、监听，用户端关闭，产生的多次析构问题

     思路：

     > https://gitbookcpp.llfc.club/sections/cpp/boost/asio08.html
     
     - 在读写监听都对异常有处理的情况：延长Session的生命周期defer，保证Session在退出handler前的存活，最后引用计数为0时，由智能指针释放空间
     
     如果我交由监听全权负责释放空间，读写只抛出异常，不处理会有什么问题？
     
     例：当我有两个函数都抛出了异常（这在多线程、异步的程序里都很常见），就会产生double free的错误。

3. 粘包问题



​	



