https://www.hello-algo.com

##### 尾递归

有趣的是，**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。

```c++
/* 尾递归 */
int tailRecur(int n, int res) {
    // 终止条件
    if (n == 0)
        return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
```

理解：尾递归携带结果进行传递，依赖编译器优化，实现空间效率的提升。就理解而言它依旧是递归，可以通过数列的表达式进行表达。

Tip：

请注意，**许多编译器或解释器并不支持尾递归优化**。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。



##### 时间复杂度

https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#4-o2n

Look：对于log n的理解、示例



##### 数字编码

https://www.hello-algo.com/chapter_data_structure/number_encoding/#331

正数的反码和补码都是它本身

Look：反码和补码的设计由来

原码（sign-magnitude）虽然最直观，但存在一些局限性。一方面，**负数的原码不能直接用于运算**。例如在原码下计算 1+(−2) ，得到的结果是 −3 ，这显然是不对的。

为了解决此问题，计算机引入了反码（1's complement）。如果我们先将原码转换为反码，并在反码下计算 1+(−2) ，最后将结果从反码转换回原码，则可得到正确结果 −1 。

另一方面，**数字零的原码有 +0 和 −0 两种表示方式**。这意味着数字零对应两个不同的二进制编码，这可能会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。

**与原码一样，反码也存在正负零歧义问题**，因此**计算机进一步引入了补码**（2's complement）。

计算机**规定这个特殊的补码 10000000 代表 −128** 。实际上，(−1)+(−127) 在补码下的计算结果就是 −128 



### 树

#### 遍历

- 层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式。

- 前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式。



### 回溯算法

> ​	回溯算法是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。

回溯算法通常采用“深度优先搜索”来遍历解空间



### 动态规划

>  dynamic programming
>
> https://www.hello-algo.com/chapter_dynamic_programming/intro_to_dynamic_programming/#1411

---

#### 常用术语

- 将数组 `dp` 称为 <u>dp 表</u>，dp[i] 表示状态 i 对应子问题的解。
- 将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为<u>初始状态</u>。
- 将递推公式 dp[i]=dp[i−1]+dp[i−2] 称为<u>状态转移方程。</u>

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

---

#### 思路

动态规划思路的递进:

1. 回溯法-暴力搜索，将所有路径、方法**穷举**出来，找到答案。有点像当局人在走迷宫，通过不断的尝试与回退，找到一条可以出去的路。将问题抽象成数学模型--数列！可以**画出一条决策树**。暴力搜索和回溯法本质没有区别都是穷举法，只不过是否抽象出<u>状态转移方程</u>。
3. 记忆化搜索：暴力搜索产生的大量重复、冗余的计算，进行优化，在走过的路上做上标记，减少计算量
4. 动态规划：如果举例走迷宫，动态规划是从终点进行反向找寻，假设只有一条路可以到达终点，那从终点出发必然是确定的。而在代码上省去了递归的负担，是**“从底至顶”，“从已知到未知”的方法**。图形上不同于搜索，是**表状的**

---

#### 两大特性

子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。

- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的**子问题是相互依赖的**，在分解过程中会出现许多重叠子问题。
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。

动态规划常用来求解最优化问题

---

##### 最优子结构

**定义：原问题的最优解是从子问题的最优解构建得来的**。



##### 无后效性

**定义：**

​	无后效性是动态规划能够有效解决问题的重要特性之一，其定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关**。

**类比：**

​	前面在介绍动态规划思路的递进时，举了终点到起点走迷宫的例子，在理解代码和思路之间可能会有一种不和谐感，就是终点到起点总给人一种从后向前的感觉，但实际代码确是从1-n，从前向后的感觉。但仔细想想，1常常是已知的，就像a1常常作为已知条件。非常符合从已知到未知的解题思路，而迷宫从终点出发，已知从终点这一条路出发必然会被经过，这样理解就顺了。把数字比作阶梯，1--n 从1 到 n ，从底至顶的感觉是否也就来了。

​	接受了上面的思路，无后效性也就非常好理解了，因为我们是从终点出发的，走的每一条路都是已知的路，都是要成为路线的路，也就没有“这条路是不是通往终点？”的疑惑了，只用好好看着前往起点的路即可。



**Q**：若题目要求要破坏无后效性，让后一个子问题，受制于上一个问题的决择

**A：** 那么就需要将状态转移方程，变成状态转移方程组，来对抗这种有后效性的问题了。当这种有后效性的条件过多，动态规划的思路就不适用了。

---

#### 个人理解

- 希望以动态规划的方式解决代码问题时，找到状态转移方程至关重要，因为其中包含了其“连续性”，在编写代码时需要保护这种连续性，才得以继续。（source：53.最大子数组和）
- 

---

 
