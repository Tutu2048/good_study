# c++细节收获

### C++特性

---

#### 语法

---

##### 大括号

*大括号可以用于限制作用域* --让对象在大括号} 时就结束生命周期进行析构

---

##### **explicit 关键字**

```c++
class Integer {
public:
    explicit Integer(double d) {
        // 从double到Integer的转换
    }
};

Integer i = 10.5; // 错误：不能隐式转换
Integer i2 = Integer(10.5); // 正确：显式转换
```

---

##### extern

C++中对于函数的重定义问题，有内置的extern，不需要在声明时显示extern xxfunc();

---

##### 命名空间

namespace是对C语言的拓展，为了解决命名重复问题。

```cpp
using namespace std;
```

但是在同一项目中尽量不要使用namespace来偷懒，可能会导致命名空间的污染，用域符号进行限定

---

##### using

基于上面命名空间的问题，再次介绍一下`using`关键字。它设计之初是为了取代`typedef`，在c++11之后也增加了一定的特性

```cpp
using tcp= boost::asio::ip::tcp;
typedef  boost::asio::ip::tcp tcp;
//二者等价，tcp是一个boost::asio::ip命名空间下的类
```

更新后下面方式更加便捷：

```cpp
using boost::asio::ip::tcp;
```

可以之间使用 `tcp::endpoint`对`boost::asio::ip::tcp::endpoint`进行简写。

因为对于命名空间的导入大小 缩小到类，所以发生命名空间污染的几率更小，在一定程度上减少命名空间的书写，属于方便人和污染避免折中，也是更加推荐的方式。



---

#### 异常处理机制

> 异常无处不在，程序随时可能误入歧途！C++ 提出了新的异常处理机制！

> 异常是一种程序控制机制，与函数机制互补。

> 函数是一种以栈结构展开的上下函数衔接的程序控制系统,异常是另一种控制结构,它可以在出现“意外”时中断当前函数,并以某种机制（类型匹配）回馈给**隔代**的调用者相关的信息。

例子：

```
//调用关系
main()->A()->B()->C()
```

当C出现问题时，触发异常，直接将错误信息返回给main，而不是通过函数层层返回。

---

##### 语法

```c++
//异常发生第一现场，抛出异常
void  function( ){
        //... ...
          throw 表达式;
        //... ...
}
//在需要关注异常的地方，捕捉异常
try{
        //程序
        function();        把function至于try中
        //程序
}catch(异常类型声明){        比如只写一个int
        //... 异常处理代码 ...
}catch(异常类型 形参){       形参将会取得抛出的值
        //... 异常处理代码 ...
}catch(...){               抛出的其它异常类型，可以接收任意类型
        //
}
//如果没有catch(...)，并且没有catch子句与抛出的异常类型匹配，程序会直接中断报错。
```

---

##### 接口声明

可以在函数声明中列出可能抛出的所有异常类型，加强程序的可读性。和override设计思路一致，为了增加可读性

```cmake
int copyfile2(char *dest, char *src) throw (float, string *, int)  { }
```

这样，在阅读代码时便可知这个函数会抛出float、string*和int类型异常，增加可读性。



注意：

1. 对于异常接口的声明，在函数声明中列出可能抛出的所有异常类型
2. 如果没有包含异常接口声明，此函数可以抛出**任何类型**的异常
3. 如果函数声明中有列出可能抛出的所有异常类型,那么抛出其它类型的异常讲可能导致程序终止（对于有些编译器可以抛出其它未在声明列表中的异常类型，如老式VC++）
4. 如果一个函数**不想抛出任何异常**，可以使用 **throw ()** 声明（有些编译器会警告throw()，如老式VC++）
5. 引用catch和非引用catch会导致catch冲突

---

##### 标准库里的异常类

![c2793b31742bd4fa1be241f59884e11e](E:\MarkDown\picture\c2793b31742bd4fa1be241f59884e11e.png)





![e877b9e74bd4a4068121c67f808a3396](E:\MarkDown\picture\e877b9e74bd4a4068121c67f808a3396.png)

---

#### 智能指针

> 对对象进行内存管理，在指针对象退出生命周期时，析构，并将其保管的内存进行释放

##### shared_ptr

> 引用计数的提出，减少内存创销，提高效率

:warning: 作为入参时，

- `const std::shared_ptr<xx> &` 的方式，这样可以避免不必要的 `std::shared_ptr` 拷贝，同时确保对象在函数内部不会被删除。
- 当然`std::shared_ptr<xx>`也可以，只不过会发生一次拷贝。
- `std::shared_ptr<xx>&`的方式是**不被允许的**，会导致指针的管理的错乱，就调用方而言，其生命周期已经结束，而对于被调用方而言，它可能还在使用该指针对内容进行操作

:grey_exclamation:例： `std::shared_ptr<std::thread>` 

当`shared_ptr`管理线程时，需要注意的是主线程依旧需要`join()`等待子线程的完成。`shared_ptr`可以自动**回收线程对象的资源**，但是它**不会自动等待线程完成执行**。主线程意外的崩溃，`shared_ptr`可以将资源进行回收，但是所有子线程直接终止。或者主线程没有等待子线程的完成，直接进行后续的操作，如果有关子线程，可能会导致错误。

简单来说：智能指针管理线程，依旧需要手动join()保证程序同步关系。

⭐⭐⭐ **重要技巧：**容器包含shared_ptr时，也做了一次拷贝，会使得引用计数加一，这样就可以通过容器操作来控制延长、缩短对象的生命周期。

---

---

### STD标准库

---

#### 容器

---

##### **std::string无法被标准输入流输出问题(windows vs)**

```c++
#include <iostream>
using namespace std;
int main(){
	string str("hello world");
    cout <<str<<endl;
}
```

STL中的许多头文件都**间接地包含了`<xstring>`**（但不要试图直接包含`<xstring>`），这就保证了你可以仅`include`这些头文件（如本例的`#include <iostream>`）就可使用`std::string`类，**导致ide可以找到string不会爆红**，而`<xstring>`中没有实现操作符<<的重载，所以在编译时会报错。问题很隐蔽。

---

##### **std::vector**初始化问题

```c++
//方式1
vector<int> v(n,0);
//方式2
vector<int> v;
v.reserve(n);
```

方式1：分配内存的同时用0来初始化n个空间

方式2：仅分配内存

这就导致方式二在后续使用时要注意，先赋值再访问，否则会导致脏数据。

- 方式2是一种更加迅速和快捷的初始化方式，当在拥有自己的初始化方式的时候用方式二来提升一定的性能。
- 方式一是更加健壮的方法

---



#### 多线程

---

##### pthread

> C

`pthread_detach` 是一个 POSIX 线程（pthread）函数，用于将一个线程设置为“分离”状态（detached state）。在 pthreads 库中，线程可以是“连接”的（joined）或“分离”的（detached）。

- **连接线程（Joined Thread）**：当一个线程结束时，它不会立即被销毁，而是保持在退出状态，直到另一个线程调用 `pthread_join` 来回收它的资源和获取它的返回值。
- **分离线程（Detached Thread）**：分离线程在结束时会自动被销毁，不需要其他线程调用 `pthread_join` 来回收它的资源。如果一个线程是分离的，它的返回值不能被其他线程获取。

使用 `pthread_detach` 函数可以将一个已经运行的线程设置为分离状态。如果线程已经结束，`pthread_detach` 会立即销毁它并回收资源。如果线程还未结束，它将在结束时自动被销毁。

---

##### **回调函数**

为什么需要回调函数

---

##### **lock_guard unique_lock**

功能：防止忘记解锁，设计理念类似于智能指针的锁保护，在析构时自动解锁

用法：

```c++
lock_guard<mutex> guard(mt);
```

而`lock_guard`没有中途解锁的缺陷，所在地方的生命周期过长，会导致一直处于上锁状态，颗粒度过大，由此出现了`unique_lock`

用法：

```c++
unique_lock<mutex> unique(mt);
//...
unique.unlock()
```

总结：感觉用处不大

---

##### std::atomic

`std::atomic<T>` c++11引入提供原子操作，由硬件处理，非常高效

---

##### enable_shared_from_this

> (C++11)

这是一个类，内部拥有一个weak_ptr，继承该类可以实现在类函数获取指向自身的shared_ptr。



这个实现的前提，问题是

- 一旦原生指针交予智能指针管理，除却第一次初始化时的原生指针的使用，对于对象的操作都应该使用智能指针，对于原生指针的使用都应该视为非法操作，所以类内是无法获取shared_ptr的。
- weak_ptr 不拥有对象，用于观察shared_ptr的管理情况，可以通过lock()函数来获取一个shared_ptr，从此拥有对象，可以使用对象的function。

当继承了该类之后，想要自身的智能指针时，就可以使用`shared_from_this()`方法来获取，就不会在类内部创建this的智能指针，则不会导致两个智能指针管理同一片内存的问题。

---

##### make_shared

- **内存分配**：
  - **`std::shared_ptr` 直接创建**：当你直接使用 `new` 关键字创建一个对象，然后将其包装在一个 `std::shared_ptr` 中时，对象和它的引用计数是分开分配的。这意味着分配两次内存：一次用于对象本身，一次用于引用计数器。
  - **`std::make_shared`**：这个函数会一次性分配足够的内存来存储对象和它的引用计数器（通常还包括一个弱引用计数器）。这种方式被称为“联合分配”（combined allocation），可以减少内存分配的次数，从而提高性能。
- **异常安全性**：
  - **`std::shared_ptr` 直接创建**：如果 `new` 操作符抛出异常，那么 `std::shared_ptr` 将不会被创建，但是 `delete` 操作仍然需要被调用以释放内存。这需要你手动管理，增加了代码的复杂性和出错的可能性。
  - **`std::make_shared`**：它提供了异常安全的保证。如果 `new` 操作符抛出异常，`make_shared` 会保证不会有内存泄漏，因为它会负责释放已经分配的内存。
- **性能**：
  - 使用 `std::make_shared` 通常比直接创建 `std::shared_ptr` 性能更好，因为它减少了内存分配的次数。
- **使用场景**：
  - **`std::shared_ptr` 直接创建**：适用于那些需要立即将一个裸指针转换为 `shared_ptr` 的情况，或者当你需要在创建 `shared_ptr` 时传递额外的参数给构造函数。
  - **`std::make_shared`**：适用于创建新的 `shared_ptr` 实例，特别是当你需要创建对象并立即管理它的生命周期时。

**总结：优先使用make_shared创建共享指针**

---

##### promise、future

//TODO：理解、例子

主要是为了解决多线程编程中的**线程间同步和数据传递**问题。在 C++11 之前，线程间的数据共享和通信通常涉及到复杂的锁机制、条件变量或其他同步原语，这些机制往往难以正确使用，且容易导致死锁、竞态条件等问题。`std::promise` 和 `std::future` 提供了一种更高层次的抽象，使得线程间的通信变得更加安全和简洁。



---

### 泛式编程

##### typename

```c++
proxy = (typename T::element_type*)(pServantProxy);
```

在这代码中，typename关键字告诉编译器，接下来的是一个类型名称

---

```
std::promise` 和 `std::future
```

