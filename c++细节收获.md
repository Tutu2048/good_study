# c++细节收获

### C++特性

---

#### 语法

---

##### 类和对象

类是抽象的，对象是实例。其最大的功能就是**携带资源！！！**

| 函数                   | 生成条件                                                     | 行为特点               |
| :--------------------- | :----------------------------------------------------------- | :--------------------- |
| 默认构造函数           | 未声明任何构造函数时生成                                     | 成员默认构造           |
| 析构函数               | 未声明析构函数时生成                                         | 成员逐次析构           |
| 拷贝构造函数           | 未声明拷贝构造时生成                                         | 浅拷贝                 |
| 拷贝赋值运算符         | 未声明拷贝赋值时生成                                         | 浅拷贝                 |
| 移动构造函数 (C++11)   | 未声明拷贝构造、拷贝赋值、移动构造、移动赋值、析构函数时生成 | 移动语义（若成员支持） |
| 移动赋值运算符 (C++11) | 同上                                                         | 移动语义（若成员支持） |

tips：

- 当一个类显式删除了拷贝构造函数（即使用 `= delete`），**编译器不会自动生成默认的移动构造函数**。这是因为拷贝构造函数的显式声明（包括删除）会抑制默认移动构造函数的生成。移动赋值也是一样。这也是为什么单例模式只需要显示delete拷贝构造和拷贝赋值，就可以保证实例的唯一性了。

---

##### 大括号{}

1. *大括号可以用于限制作用域* --让对象在大括号} 时就结束生命周期进行析构

2. c++11 引入{}用做初始化操作

   ```c++
   class A{};
   A x{1};//c++11
   ```

   Q：为什么要引入这个机制？

   A：因为在调用复杂初始时，编译器存在将初始化操作（调用构造函数）构造对象，理解成定义了一个返回值为 A的函数定义。

   例：

   ```c++
   class background_task {
   public:
       void operator()(std::string str) {
           std::cout << "str is " << str << std::endl;
       }
   };
   std::thread t2(background_task());
   ```

   这时编译器将`std::thread t2(background_task());`理解成`"std::thread (*)(background_task (*)())"`

   - 返回值为thread ；
   - 函数名t2；
   - 参数为一个返回值、参数都为空的函数指针； 

   的一个函数定义。

   所以引入{}用做构造对象的方式来避免歧义



---

##### **explicit 关键字**

```c++
class Integer {
public:
    explicit Integer(double d) {
        // 从double到Integer的转换
    }
};

Integer i = 10.5; // 错误：不能隐式转换
Integer i2 = Integer(10.5); // 正确：显式转换
```

---

##### extern

C++中对于函数的重定义问题，有内置的extern，不需要在声明时显示extern xxfunc();

---

##### 命名空间

namespace是对C语言的拓展，为了解决命名重复问题。

```cpp
using namespace std;
```

但是在同一项目中尽量不要使用namespace来偷懒，可能会导致命名空间的污染，用域符号进行限定

---

##### using

基于上面命名空间的问题，再次介绍一下`using`关键字。它设计之初是为了取代`typedef`，在c++11之后也增加了一定的特性

```cpp
using tcp= boost::asio::ip::tcp;
typedef  boost::asio::ip::tcp tcp;
//二者等价，tcp是一个boost::asio::ip命名空间下的类
```

更新后下面方式更加便捷：

```cpp
using boost::asio::ip::tcp;
```

可以之间使用 `tcp::endpoint`对`boost::asio::ip::tcp::endpoint`进行简写。

因为对于命名空间的导入大小 缩小到类，所以发生命名空间污染的几率更小，在一定程度上减少命名空间的书写，属于方便人和污染避免折中，也是更加推荐的方式。

---

##### inline

TODO::内联的学习

> https://zh.cppreference.com/w/cpp/language/inline
>
> cpp参考手册

---

##### delete

> c++11

`=delete` 的实现**依赖于编译器**，但基本思想是在编译时期检查函数调用，并在发现被删除的函数被调用时产生编译错误。

> 《Effective c++》

但在c++11之前如何防止拷贝，常规方式是仅声明不实现这种方式并将其放在private中，在调用时链接器会报警，而有一种利用继承权限思路的方式，可以将告警提前到编译器时期，使得编程更加优雅。

```cpp

```

//TODO 根据书籍填写完整



---

##### 继承权限

public、protected、private

三种权限出现在类内部和继承时，有着不同的意义，需要去区分。

当出现在**类内部**时，该权限限制的对象是实例对象和外部类(包括子类)

当出现在**继承**时，缩小继承来的成员权限，private就是将父类继承来的所有成员归为自己所有，此时实例对象和外部类便无法访问，但类自身仍然可以使用，因为这是自己的成员。

> 形象描述：师傅传功，徒弟们都能学，学到了就是自己的，但有人愿意将武功传承下去广收门徒，有人不想武功失传便将武功传给子嗣，有人却觉得武功太过霸道，伤人伤己想断了这份传承。而传承也分三六九等，不可能把所有绝学都授予每一个人，这也就有了门规，何术可渡世人、何术只传本门人、何法不可传。作为传承者需受自身心境和门规两重约束，但创派者只需随心即可。



---

##### Lambda表达

捕获列表用于指定从周围作用域中捕获哪些变量。语法如下：

- `[=]`：捕获所有局部变量按值。
- `[&]`：捕获所有局部变量按引用。
- `[a, &b]`：捕获变量`a`按值，变量`b`按引用。
- `[this]`：捕获当前对象的`this`指针。

Tips：在**异步**传递lambda表达作为函数token的时候，它的流程是将函数**交由调度器去感知触发和执行**，不仅仅需要注意参数，也需要注意**捕获变量的生命周期**。因为它**并不是顺序执行的**！其中变量很可能出现变化导致程序错误。

---

##### R()

R”(….)”  可以获得一个原生的字符串，即不会转义。c++11↑

```c++
string s = R"(hello world)";
```

---

##### const

```c++
int a()const; 
```

在C++中，成员函数后面如果加上了 const 关键字，表示这个成员函数是“const成员函数”。const成员函数承诺不会修改它所属对象的状态，也就是说，它不会改变对象的任何成员变量的值。

---

##### 小括号（）重载

重载小括号作符（`operator()`）主要用于为类的对象提供函数调用的语法糖，使得对象能够像函数一样被调用

- **灵活性**：函数对象可以**维护内部状态**，而普通的函数指针无法做到这一点。
- **性能优化**：在某些情况下，函数对象的内联调用比函数指针调用更高效。

就像开头”类与对象“节所说，类、对象的功能就是携带资源，可以保存的资源。

---

##### return

- 我们都知道在return时，会发生拷贝，那如果返回的是一个类，会发生拷贝构造，为了避免拷贝构造，常常使用引用&符号来进行返回。这里有一个小点，如果返回值为类A，而A并没有拷贝构造，则会**使用A的移动构造**

- return时必然发生拷贝，我们要避免拷贝的开销，要合理使用引用和智能指针去管理内存。也可以减少内存导致的异常发生的几率。

  ```c++
  vector<A> changeVec(std::stack<vector<A>> data ){
  		auto element = data.top();
  		data.pop();
  		return element;//return时拷贝失败，element随着大括号丢失数据，stack中也依旧pop
  }
  ```

  上面代码存在两次拷贝，一次时element的复制，一次是return时的复制，对于大容量的vector很可能因为机器的内存原因导致拷贝失败，引发问题。解决方案：

  - 容器中存储智能指针，`shared_ptr<vector<A>> changeVec(std::stack<shared_ptr<vector<A>>> data )` 
  - 增加引用 ，`void changeVec(std::stack<vector<A>> data,vector<A>& ret)`

  两种方式，都可以减少一次vector的拷贝，并将内存拷贝的风险有效控制在函数内部，而不是末尾。且能够在拷贝失败时，依旧保存data栈中的数据，以便后续异常处理，不会因此丢失数据

---

##### mutable

> 可变的

```c++
class A{
	int dontChangeFunc const(){
			_v++;
	}
  mutable int _v;
}
```

即使在标注const的函数中，依旧可以修改`_v`的值

---

##### **throw()&noexcept**

> `throw()` 表示这个函数不会抛出任何异常（在 C++11 及以后版本中，推荐使用 `noexcept` 替代 `throw()`）。

```c++
const char * what() throw();//
const char * what() noexcept;//c++11 ⬆️
```

---

##### friend

> 使得类和函数，能访问本类中内容

在实际工作场景中，friend还可以实现调用结构的改变，常有例如：

```c++
class A{
		friend void swap(A& e1,A& e2){
      A tmp = std::move(e1);
      e1 =std::move(e2);
      e2 =std::move(tmp);
    }
}
```

交换数据的swap函数用友元，是为了让swap可以直接swap(b1,b2)这样调用，若是成员函数，那就只能b1.swap(b2)这样调用

 

---

#### 异常处理机制

> 异常无处不在，程序随时可能误入歧途！C++ 提出了新的异常处理机制！

> 异常是一种程序控制机制，与函数机制互补。

> 函数是一种以栈结构展开的上下函数衔接的程序控制系统,异常是另一种控制结构,它可以在出现“意外”时中断当前函数,并以某种机制（类型匹配）回馈给**隔代**的调用者相关的信息。

例子：

```
//调用关系
main()->A()->B()->C()
```

当C出现问题时，触发异常，直接将错误信息返回给main，而不是通过函数层层返回。



---

##### 语法

```c++
//异常发生第一现场，抛出异常
void  function( ){
        //... ...
          throw 表达式;
        //... ...
}
//在需要关注异常的地方，捕捉异常
try{
        //程序
        function();        把function至于try中
        //程序
}catch(异常类型声明){        比如只写一个int
        //... 异常处理代码 ...
}catch(异常类型 形参){       形参将会取得抛出的值
        //... 异常处理代码 ...
}catch(...){               抛出的其它异常类型，可以接收任意类型
        //
}
//如果没有catch(...)，并且没有catch子句与抛出的异常类型匹配，程序会直接中断报错。
```

---

##### 接口声明

可以在函数声明中列出可能抛出的所有异常类型，加强程序的可读性。和override设计思路一致，为了增加可读性

```cmake
int copyfile2(char *dest, char *src) throw (float, string *, int)  { }
```

这样，在阅读代码时便可知这个函数会抛出float、string*和int类型异常，增加可读性。



注意：

1. 对于异常接口的声明，在函数声明中列出可能抛出的所有异常类型
2. 如果没有包含异常接口声明，此函数可以抛出**任何类型**的异常
3. 如果函数声明中有列出可能抛出的所有异常类型,那么抛出其它类型的异常讲可能导致程序终止（对于有些编译器可以抛出其它未在声明列表中的异常类型，如老式VC++）
4. 如果一个函数**不想抛出任何异常**，可以使用 **throw ()** 声明（有些编译器会警告throw()，如老式VC++）
5. 引用catch和非引用catch会导致catch冲突

---

##### 标准库里的异常类

![c2793b31742bd4fa1be241f59884e11e](.\picture\c2793b31742bd4fa1be241f59884e11e.png)





![e877b9e74bd4a4068121c67f808a3396](.\picture\e877b9e74bd4a4068121c67f808a3396.png)



##### 补充

**throw**

在 C++11 之前，C++ 使用异常规范（如 `throw()`）来声明函数可能抛出的异常类型。然而，这些规范在实践中被证明是有缺陷的，并且在 C++11 标准中被弃用。C++11 引入了 `noexcept` 作为 `throw()` 的首选替代项

**为什么有缺陷：**

1. **虚假的安全感**： 异常规范可能会给开发者一种错误的安全感。例如，如果一个函数声明为 `throw()`，即不抛出任何异常，开发者可能会错误地认为调用这个函数是完全安全的，而忽略了可能发生的错误情况。
2. **违反异常规范的未定义行为**： 如果一个函数违反了它的异常规范（例如，一个声明为 `throw(A)` 的函数抛出了类型 `B` 的异常），在 C++ 标准中这种行为是未定义的。这意味着编译器可以采取任何行动，包括忽略该异常。这可能导致难以发现和调试的错误。
3. **优化问题**：...

简单来说，就是规范的设置和程序编写自由之间产生的冲突，`nonexcept`更加简单有效。

**noexcept**

设定函数为不会抛出异常的，若出现异常，可以被catch 进行异常操作，若没有catch进行捕获，会被直接terminate()

而在 C++17 中，`noexcept`、`noexcept(true)` 和 `throw()` 都是等效的，并且在从用上述任何规范声明的函数引发异常时，将按 C++17 标准要求调用 `std::terminate`。

注意版本之间的对于throw的处理

---

#### 智能指针

> 对对象进行内存管理，在指针对象退出生命周期时，析构，并将其保管的内存进行释放

##### shared_ptr

> 引用计数的提出，减少内存创销，提高效率

:warning: 作为入参时，

- `const std::shared_ptr<xx> &` 的方式，这样可以避免不必要的 `std::shared_ptr` 拷贝，同时确保对象在函数内部不会被删除。
- 当然`std::shared_ptr<xx>`也可以，只不过会发生一次拷贝。
- `std::shared_ptr<xx>&`的方式是**不被允许的**，会导致指针的管理的错乱，就调用方而言，其生命周期已经结束，而对于被调用方而言，它可能还在使用该指针对内容进行操作

:grey_exclamation:例： `std::shared_ptr<std::thread>` 

当`shared_ptr`管理线程时，需要注意的是主线程依旧需要`join()`等待子线程的完成。`shared_ptr`可以自动**回收线程对象的资源**，但是它**不会自动等待线程完成执行**。主线程意外的崩溃，`shared_ptr`可以将资源进行回收，但是所有子线程直接终止。或者主线程没有等待子线程的完成，直接进行后续的操作，如果有关子线程，可能会导致错误。

简单来说：智能指针管理线程，依旧需要手动join()保证程序同步关系。

⭐⭐⭐ **重要技巧：**容器包含shared_ptr时，也做了一次拷贝，会使得引用计数加一，这样就可以通过容器操作来控制延长、缩短对象的生命周期。



---

##### 当智能指针碰上继承类

当智能指针碰上继承类时，需要注意的是对内存的管理，也就是析构函数的权限问题。

智能指针管理对象时，其**析构函数必须为public**，因为对于被管理类而言智能指针类属于外部类，无法直接访问其析构函数。而被管理对象为子类时，需要注意其父类的析构函数应该被智能指针类所访问，但它并不是以外部类的身份去访问的，（猜测）是以子类成员的身份去访问父类析构的，所以**父类权限大于等于protected**就可以了

---

##### unique_ptr

> `std::unique_ptr` 是一种智能指针，用于管理动态分配的资源，并且保证资源的唯一所有权。这意味着一个 `std::unique_ptr` 实例在任何时候只能拥有一个指向动态分配对象的指针。当你使用 `std::unique_ptr` 时，它会自动为你管理内存，当 `std::unique_ptr` 被销毁时，它会自动释放其所拥有的资源。

注：unique_ptr**不允许拷贝构造**，但是允许移动构造



---

---

### STD标准库

---

#### 容器

---

##### **std::string无法被标准输入流输出问题(windows vs)**

```c++
#include <iostream>
using namespace std;
int main(){
	string str("hello world");
    cout <<str<<endl;
}
```

STL中的许多头文件都**间接地包含了`<xstring>`**（但不要试图直接包含`<xstring>`），这就保证了你可以仅`include`这些头文件（如本例的`#include <iostream>`）就可使用`std::string`类，**导致ide可以找到string不会爆红**，而`<xstring>`中没有实现操作符<<的重载，所以在编译时会报错。问题很隐蔽。

---

##### **std::vector**

- **<u>初始化问题</u>**

  ```c++
  //方式1
  vector<int> v(n,0);
  //方式2
  vector<int> v;
  v.reserve(n);
  ```

  方式1：分配内存的同时用0来初始化n个空间

  方式2：仅分配内存

  这就导致方式二在后续使用时要注意，先赋值再访问，否则会导致脏数据。

  - 方式2是一种更加迅速和快捷的初始化方式，当在拥有自己的初始化方式的时候用方式二来提升一定的性能。
  - 方式1是更加健壮的方法

- <u>**reserve**</u>

  vector 的reserve函数，仅reserve，是无法使用[]下标去给容器进行增加操作的

---

​									<!----Cap End---->

---

#### 多线程

##### pthread

> C

`pthread_detach` 是一个 POSIX 线程（pthread）函数，用于将一个线程设置为“分离”状态（detached state）。在 pthreads 库中，线程可以是“连接”的（joined）或“分离”的（detached）。

- **连接线程（Joined Thread）**：当一个线程结束时，它不会立即被销毁，而是保持在退出状态，直到另一个线程调用 `pthread_join` 来回收它的资源和获取它的返回值。
- **分离线程（Detached Thread）**：分离线程在结束时会自动被销毁，不需要其他线程调用 `pthread_join` 来回收它的资源。如果一个线程是分离的，它的返回值不能被其他线程获取。

使用 `pthread_detach` 函数可以将一个已经运行的线程设置为分离状态。如果线程已经结束，`pthread_detach` 会立即销毁它并回收资源。如果线程还未结束，它将在结束时自动被销毁。

---

##### **回调函数**

为什么需要回调函数

---

##### **lock_guard unique_lock**

功能：防止忘记解锁，设计理念类似于智能指针的锁保护，在析构时自动解锁

用法：

```c++
lock_guard<mutex> guard(mt);

mt1.lock();
lock_guard<mutex> guard1(mt1,std::adopt_lock);

lock_guard<mutex> guard2(mt2,std::defer_lock);
guard2.lock();
```

- **std::adopt_lock** 领养锁，也就是gurad只负责mt1的释放，不负责mt1的加锁
- **std::defer_lock** 延迟锁，创建锁对象时**不立即锁定互斥量**，后续需要手动调用 `lock()` 或结合 `std::lock()` 锁定,需要同时锁定多个互斥量时使用（避免死锁）。

而`lock_guard`没有中途解锁的缺陷，所在地方的生命周期过长，会导致一直处于上锁状态，颗粒度过大，由此出现了`unique_lock`

用法：

```c++
unique_lock<mutex> unique(mt);
//...
unique.unlock()
```



---

##### std::atomic

`std::atomic<T>` c++11引入提供原子操作，由硬件处理，非常高效

---

##### enable_shared_from_this

> (C++11)

这是一个类，内部拥有一个weak_ptr，继承该类可以实现在类函数获取指向自身的shared_ptr。



这个实现的前提，问题是

- 一旦原生指针交予智能指针管理，除却第一次初始化时的原生指针的使用，对于对象的操作都应该使用智能指针，对于原生指针的使用都应该视为非法操作，所以类内是无法获取shared_ptr的。
- weak_ptr 不拥有对象，用于观察shared_ptr的管理情况，可以通过lock()函数来获取一个shared_ptr，从此拥有对象，可以使用对象的function。

当继承了该类之后，想要自身的智能指针时，就可以使用`shared_from_this()`方法来获取，就不会在类内部创建this的智能指针，则不会导致两个智能指针管理同一片内存的问题。



tips：使用`shared_from_this`之前必须有一个与对象相关的`shared_ptr`

---

##### make_shared

- **内存分配**：
  - **`std::shared_ptr` 直接创建**：当你直接使用 `new` 关键字创建一个对象，然后将其包装在一个 `std::shared_ptr` 中时，对象和它的引用计数是分开分配的。这意味着分配两次内存：一次用于对象本身，一次用于引用计数器。
  - **`std::make_shared`**：这个函数会一次性分配足够的内存来存储对象和它的引用计数器（通常还包括一个弱引用计数器）。这种方式被称为“联合分配”（combined allocation），可以减少内存分配的次数，从而提高性能。
- **异常安全性**：
  - **`std::shared_ptr` 直接创建**：如果 `new` 操作符抛出异常，那么 `std::shared_ptr` 将不会被创建，但是 `delete` 操作仍然需要被调用以释放内存。这需要你手动管理，增加了代码的复杂性和出错的可能性。
  - **`std::make_shared`**：它提供了异常安全的保证。如果 `new` 操作符抛出异常，`make_shared` 会保证不会有内存泄漏，因为它会负责释放已经分配的内存。
- **性能**：
  - 使用 `std::make_shared` 通常比直接创建 `std::shared_ptr` 性能更好，因为它减少了内存分配的次数。
- **使用场景**：
  - **`std::shared_ptr` 直接创建**：适用于那些需要立即将一个裸指针转换为 `shared_ptr` 的情况，或者当你需要在创建 `shared_ptr` 时传递额外的参数给构造函数。
  - **`std::make_shared`**：适用于创建新的 `shared_ptr` 实例，特别是当你需要创建对象并立即管理它的生命周期时。

**总结：优先使用make_shared创建共享指针**

---

##### promise、future

//TODO：理解、例子

主要是为了解决多线程编程中的**线程间同步和数据传递**问题。在 C++11 之前，线程间的数据共享和通信通常涉及到复杂的锁机制、条件变量或其他同步原语，这些机制往往难以正确使用，且容易导致死锁、竞态条件等问题。`std::promise` 和 `std::future` 提供了一种更高层次的抽象，使得线程间的通信变得更加安全和简洁。

---

##### condition_variable

> 条件变量常配合mutex互斥锁，配合使用，实现同步关系，那么如何理解条件变量?

顾名思义，条件变量是一个与条件相关的变量，它**是条件的媒介，是条件的代理人**。它的变化很可能（有虚假唤醒）意味着条件发生了变化

std帮我们写了它的成员函数wait、notify，简单看一下wait的应用：

```cpp
	std::mutex mutex;
	std::condition_variable cv;
	bool bFlag= false;
	while (!bFlag) {
		std::unique_lock<std::mutex> lock(mutex);
		cv.wait(lock);
	}
```

乍一看，好像是**cv在等待lock这个锁，实则不然**，cv等待的是在其内部管理的条件变量，而lock对应的是在**内部条件变量**发生变化时去**争抢锁的那个操作**。而bFlag这个很像条件的条件，其实所对应的层次并不是条件变量这一层，而是程序员所要实现同步的同步条件，也就是内部管理的条件变量所连接的条件。



> 在C语言中

`pthread_cond_t`就是条件变量，其实际的类型是一个int64。与之相关的`pthread_cond_wait`、`pthread_cond_signal`分别是等待`pthread_cond_t`变化和通知`pthread_cond_t`已经变化，然后对mutex进行操作。看一下C的应用。

```c
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;
bool condition = false;
void wait() {
    pthread_mutex_lock(&mutex);
    // 检查条件
    while (!condition) {
        pthread_cond_wait(&cond, &mutex); // 等待条件变量
    }
    pthread_mutex_unlock(&mutex);
}

void signal() {
    pthread_mutex_lock(&mutex);
    // 修改条件
    condition = true;
    pthread_cond_signal(&cond); // 通知等待的线程
    pthread_mutex_unlock(&mutex);
}
```



//Question:为什么c++和c在wait时，一个在里面加锁一个在外面，个人觉得放循环外面加锁更加安全。因为不管c还是c++都会在等待时释放mutex，在被唤醒时争抢mutex加锁。



:warning: 

- **虚假唤醒**：是指条件与条件变量不统一，线程被唤醒，但实际条件不满足
- **pthread_cond_wait**：signal已经执行，如果没有抢到mutex锁，程序不会执行到下一行，c++也是一样的



因为c++是在C的基础上进行封装、改造，沿用C的名称很正常，而这种原先较为清楚的逻辑关系，在封装后产生反直觉的现象也不少见，理解好设计思路，才能更好的使用。

//TODO：感觉要将条件和条件变量绑定起来一起使用才符合直觉

---

#### 工具

> Utilities

##### std::move

通常用于将一个左值（lvalue）转换为右值引用（rvalue reference）

Q：为什么要实现上面的操作？

A：是为了启用**移动语义**，所以命名为move 

作用：

- **启动移动语义**：通过将左值转换为 xvalue，`std::move` 允许对象在移动构造函数和移动赋值运算符中被转移，从而**避免不必要的复制操作**，提高性能。
- **所有权转移**：明确表示资源的所有权将从一个对象转移到另一个对象，通常用于独占资源的管理（如智能指针 `std::unique_ptr`）。

使用时机：

当一个变量在该类or域 内不再需要，想要减少拷贝的情况，使用std::move

---

##### function对象

- **target成员函数**

`func.target<size_t (*)(void* ,size_t ,size_t ,void*)>(); `

target函数可以用来获取指向函数指针的裸指针 ，在c++程序兼容c语言库时，可能需要用到



---

---

### 泛式编程

##### typename

```c++
proxy = (typename T::element_type*)(pServantProxy);
```

在这代码中，typename关键字告诉编译器，接下来的是一个类型名称

---

##### 完美类型转换

```
std::promise` 和 `std::future
```

---

##### **单例模式**

懒汉模式--延迟初始化，仅分配空间，在初次调用时初始化内容

饿汉模式--程序启动即初始化

懒汉模式存在线程安全问题，所以需要上锁等同步操作，造成一定的性能损耗

饿汉模式若对象未被使用则造成资源的浪费



但是单例类大多为程序伊始即需要初始化，

---

### 🕳

##### 逗号运算符，

它的优先级别最低

> 从左往右计算，并返回最右侧的值

在一定条件下也可能出现问题，如下：

```cpp
m_bIsLimitUpCalc.store((bCalc,std::memory_order_relaxed));
```

注意这里atomic变量使用了store函数，用于修改自身的值，但这里使用了两个括号，`(bCalc,std::memory_order_relaxed)`返回了一个std::memory_order_relaxed的值，而其值为0，导致使用store时m_bIsLimitUpCalc永远为fasle.

知道逗号运算符的作用后，需要警惕的是，括号运算符的优先级很高，在传参时需要小心！
